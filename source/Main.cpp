#include <switch.h>
#include <cstdio>
#include <sys/stat.h>
#include <string>
#include <cstring>
#include <vector>

namespace {

    constexpr const char IndexHtmlPath[] = "romfs:/index.html";
    constexpr const char OfflineHtmlBasePath[] = "sdmc:/atmosphere/hbl_html/html-document";
    constexpr const char OfflineHtmlPath[] = "sdmc:/atmosphere/hbl_html/html-document/jsdmp.htdocs";
    constexpr const char OfflineHtmlIndexHtmlPath[] = "sdmc:/atmosphere/hbl_html/html-document/jsdmp.htdocs/index.html";
    constexpr const char ActualIndexHtmlPath[] = "jsdmp.htdocs/index.html";

    constexpr const char DumpPath[] = "sdmc:/jsextension-dumper";

    bool SetHtmlContent() {
        auto f = fopen(IndexHtmlPath, "rb");
        if(f) {
            struct stat st = {};
            stat(IndexHtmlPath, &st);
            if(st.st_size > 0) {
                auto buf = new char[st.st_size]();
                fread(buf, st.st_size, 1, f);

                mkdir(OfflineHtmlBasePath, 777);
                mkdir(OfflineHtmlPath, 777);

                auto out_f = fopen(OfflineHtmlIndexHtmlPath, "wb");
                if(out_f) {
                    fwrite(buf, st.st_size, 1, out_f);
                    fclose(out_f);
                    
                    delete[] buf;
                    return true;
                }
                
                delete[] buf;
            }
            fclose(f);
        }
        return false;
    }

    void UnsetHtmlContent() {
        fsdevDeleteDirectoryRecursively(OfflineHtmlPath);
    }

    static Result WebTlvWrite(WebCommonTLVStorage *storage, u16 type, const void* argdata, u16 argdata_size, u16 argdata_size_total) {
        Result rc = MAKERESULT(Module_Libnx, LibnxError_BadInput);
        size_t i, count, offset;
        u8 *dataptr = storage->data;
        WebArgHeader *hdr = (WebArgHeader*)dataptr;
        WebArgTLV *tlv;
        size_t size = sizeof(storage->data);

        offset = sizeof(WebArgHeader);
        if (size < offset) return rc;
        if (argdata_size > argdata_size_total) argdata_size = argdata_size_total;

        count = hdr->total_entries;
        tlv = (WebArgTLV*)&dataptr[offset];

        for (i=0; i<count; i++) {
            if (size < offset + sizeof(WebArgTLV)) return rc;

            tlv = (WebArgTLV*)&dataptr[offset];

            if (tlv->type == type) {
                if (tlv->size != argdata_size_total) return rc;
                break;
            }

            offset+= sizeof(WebArgTLV) + tlv->size;
            if (size < offset) return rc;
        }

        if (size < offset + sizeof(WebArgTLV) + argdata_size_total) return rc;

        tlv = (WebArgTLV*)&dataptr[offset];

        if (tlv->type != type) {
            if (hdr->total_entries == 0xFFFF) return rc;

            tlv->type = type;
            tlv->size = argdata_size_total;
            hdr->total_entries++;
        }

        offset+= sizeof(WebArgTLV);
        memcpy(&dataptr[offset], argdata, argdata_size);
        if (argdata_size_total != argdata_size) memset(&dataptr[offset+argdata_size], 0, argdata_size_total-argdata_size);

        return 0;
    }

    enum class MessageId : u32 {
        Message = 0x0,
        Ack = 0x1000,
    };

    struct SessionMessageHeader {
        MessageId id;
        u32 data_size;
        u8 unused[8];
    };
    static_assert(sizeof(SessionMessageHeader) == 0x10);

    struct AckMessageData {
        u32 acked_size;
        u8 unused[0x10];
    };
    static_assert(sizeof(AckMessageData) == 0x14);

    std::vector<std::string> queued_dump_lines;
    std::string dump_object_name;
    std::string filename;

    void ProcessRequestMessage(u8 *message, u32 message_len) {
        std::string msg(reinterpret_cast<char*>(message), message_len);
        if(msg.substr(0, 2) == "*$") {
            queued_dump_lines.clear();
            dump_object_name = msg.substr(2);

            mkdir(DumpPath, 777);
            filename = std::string(DumpPath) + "/" + dump_object_name + ".dump.log";

            auto f = fopen(filename.c_str(), "w");
            if(f) {
                fprintf(f, "\nJsExtension dumper - autogenerated dumps of JavaScript objects\n * Dump of object '%s':\n\n", dump_object_name.c_str());
                fclose(f);
            }
        }
        else {
            auto f = fopen(filename.c_str(), "a+");
            if(f) {
                fprintf(f, "%s", msg.c_str());
                fclose(f);
            }
        }
    }

    void ProcessMessage(AppletHolder *h, u8 *data, s64 size) {
        auto header = reinterpret_cast<SessionMessageHeader*>(data);
        auto message_data = data + sizeof(SessionMessageHeader);
        auto message_len = header->data_size;
        switch(header->id) {
            case MessageId::Ack: {
                // ???
                break;
            }
            case MessageId::Message: {
                ProcessRequestMessage(message_data, message_len);
                SessionMessageHeader ack_header = { MessageId::Ack, sizeof(AckMessageData), {0} };
                AckMessageData ack = { header->data_size, {0} };
                u32 extra_pad = 0;

                AppletStorage ack_st;
                appletCreateStorage(&ack_st, sizeof(ack_header) + sizeof(ack) + sizeof(extra_pad));
                appletStorageWrite(&ack_st, 0, &ack_header, sizeof(ack_header));
                appletStorageWrite(&ack_st, sizeof(ack_header), &ack, sizeof(ack));
                appletStorageWrite(&ack_st, sizeof(ack_header) + sizeof(ack), &extra_pad, sizeof(extra_pad));
                appletHolderPushInteractiveInData(h, &ack_st);
                appletStorageClose(&ack_st);
                break;
            }
        }
    }

    /*
    void SendMessage(const std::string &str) {
        const auto msg_len = str.length() + 1;
        SessionMessageHeader header = { MessageId::Ack, msg_len, {0} };

        AppletStorage msg_st;
        appletCreateStorage(&msg_st, sizeof(header) + msg_len);
        appletStorageWrite(&msg_st, 0, &header, sizeof(header));
        appletStorageWrite(&msg_st, sizeof(header), str.c_str(), msg_len);

        appletHolderPushInteractiveInData(h, &msg_st);
        appletStorageClose(&ack_st);
    }
    */

}

int main() {
    romfsInit();
    
    if(SetHtmlContent()) {
        WebCommonConfig web;
        webOfflineCreate(&web, WebDocumentKind_OfflineHtmlPage, 0, ActualIndexHtmlPath);

        webConfigSetJsExtension(&web, true);
        
        u32 session_boot_mode = 0;
        WebTlvWrite(&web.arg, WebArgType_SessionBootMode, &session_boot_mode, sizeof(session_boot_mode), sizeof(session_boot_mode));

        bool session_flag = true;
        WebTlvWrite(&web.arg, WebArgType_SessionFlag, &session_flag, sizeof(session_flag), sizeof(session_flag));

        u32 la_version = 0x80000;
        appletCreateLibraryApplet(&web.holder, AppletId_offlineWeb, LibAppletMode_AllForeground);

        LibAppletArgs la;
        libappletArgsCreate(&la, la_version);
        libappletArgsPush(&la, &web.holder);

        libappletPushInData(&web.holder, &web.arg, sizeof(web.arg));
        appletHolderStart(&web.holder);

        while(true) {
            if(appletHolderWaitInteractiveOut(&web.holder)) {
                AppletStorage st;
                appletHolderPopInteractiveOutData(&web.holder, &st);

                s64 st_size;
                appletStorageGetSize(&st, &st_size);
                if(st_size > 0) {
                    auto data = new u8[st_size]();
                    appletStorageRead(&st, 0, data, st_size);
                    ProcessMessage(&web.holder, data, st_size);
                    delete[] data;
                }
                appletStorageClose(&st);
            }
            else {
                break;
            }
        }

        appletHolderJoin(&web.holder);
        appletHolderClose(&web.holder);

        UnsetHtmlContent();
    }

    romfsExit();
    return 0;
}